// CUP specification for a simple expression evaluator (w/ actions)
package compilers;

import ast.enumerated_types.*;
import ast.*;
import java_cup.runtime.*;
import java.util.List;

parser code  {: 

	/* override error routines */

  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");
    if (info instanceof java_cup.runtime.Symbol) {
     int column = ((java_cup.runtime.Symbol) info).right; //num of column
     int line = ((java_cup.runtime.Symbol) info).left;//num of line
     Object value = ((java_cup.runtime.Symbol) info).value;//value
     m.append("in ");
     m.append( "Line: "+(line + 1)+" " );
     m.append( "Column: "+(column + 1)+" " );
     m.append( "Value: "+value.toString()+" " );
     System.out.println(m);
    }
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  } 
  
:};

action code {:

	Program program;

:}


/* Terminals (tokens returned by the scanner). */

/* keywords terminal */

terminal BOOL, BREAK, CLASS, CONTINUE, ELSE, FOR, IF, RETURN, VOID, WHILE, EXTERN;
terminal POINT, COMA, LPAR, RPAR, LKEY, RKEY, LBRACKET, RBRACKET, NOT, SEMICOLON;
terminal String TRUE, FALSE, ID, FLOAT, INTEGER;


/* operations terminal */

terminal MINUS, UMINUS, PLUS, PRODUCT, DIVIDE, MOD;
terminal LESS, HIGH, LESS_EQ, HIGH_EQ;
terminal EQUAL, DISTINCT;
terminal AND, OR;
terminal ASSIGN, INC, DEC;

/* literals */
terminal Integer INTEGER_LITERAL;
terminal Float FLOAT_LITERAL;

/* Non-terminals */
non terminal Program program;
non terminal DeclarationClass class_decl;
non terminal FieldDeclaration field_decl, field_decls;
non terminal Identifier identifier, identifiers;
non terminal method_decl, method_decls, arguments_decl;
non terminal Type type;
non terminal Block block;
non terminal body;
non terminal Statement statement, statements;
non terminal Expression expr, exprs;
non terminal Location location;
non terminal method_call;
non terminal IdName id;
non terminal Literal literal;
non terminal BoolLiteral boolean_literal;
non terminal AssignOpType assing_op;

/* Precedences (in order from lowest to highest priority) */

precedence left OR;
precedence left AND;
precedence nonassoc EQUAL, DISTINCT;
precedence nonassoc LESS, HIGH, LESS_EQ, HIGH_EQ; 
precedence left MINUS, PLUS;
precedence left UMINUS;
precedence left PRODUCT, DIVIDE, MOD;
precedence left ELSE;


/* The grammar */
			
start with program;			
		
program ::= class_decl:c {: RESULT = new Program(c); :}
		| class_decl:c program:p {: p.addDeclarationClass(c); RESULT = p; :}
		;

class_decl ::= CLASS ID LKEY  RKEY
		| CLASS ID LKEY field_decls RKEY
		| CLASS ID LKEY method_decls RKEY
		| CLASS ID LKEY field_decls method_decls RKEY
		;

field_decls ::= field_decl //Just one field declaration
		| field_decls field_decl //At least two fields are declarated
		;

field_decl ::= type identifiers SEMICOLON
		;

identifiers ::= identifier //Only one identifier
		| identifiers COMA identifier //At least two identifiers
		;

identifier ::= ID //New identifier
		| ID LBRACKET INTEGER_LITERAL RBRACKET
		;

method_decls ::= method_decl
		| method_decls method_decl
		;		

method_decl ::= type ID LPAR RPAR body
		| type ID LPAR arguments_decl RPAR body
		;
		
arguments_decl ::= type ID
		| arguments_decl COMA type ID
		;

body ::= block
		| EXTERN SEMICOLON
		;
		
block ::= LKEY RKEY
		| LKEY field_decls RKEY
		| LKEY statements RKEY
		| LKEY field_decls statements RKEY
		;

        
type ::= INTEGER {: RESULT = Type.INTEGER; :}
		| FLOAT {: RESULT = Type.FLOAT; :}
		| BOOL {: RESULT = Type.BOOL; :}
		| VOID {: RESULT = Type.VOID; :}
		| ID 
		;

statements ::= statement:stmt {: RESULT = new StatementList(stmt); :}
		| statements:stmts statement:stmt {: stmts.addStatementToList(stmt); RESULT = stmts;  :}
		;
		
statement ::= location assing_op expr SEMICOLON
		| method_call SEMICOLON
		| IF LPAR expr RPAR statement 
		| IF LPAR expr RPAR statement ELSE statement
		| FOR ID ASSIGN expr COMA expr statement
		| WHILE expr statement
		| RETURN SEMICOLON
		| RETURN expr SEMICOLON
		| BREAK SEMICOLON
		| CONTINUE SEMICOLON
		| SEMICOLON
		| block
		;
		
method_call ::= id:i LPAR RPAR {: RESULT = new MethodCallExpr(i); :}
		| id:i LPAR exprs:e RPAR {: RESULT = new MethodCallExpr(i,e); :}
		;

exprs ::= expr:e {: RESULT = new ExpressionList(e); :}
		| exprs:es COMA expr:e {: es.addExpressionToList(e); RESULT = es; :}
		;

location ::= id:i {: RESULT = new LocationExpr(i); :}
		| id:i LBRACKET expr:e RBRACKET {: RESULT = new LocationExpr(i,e); :}
		;

id ::= ID:i {: RESULT = new IdName(i); :}
		| ID:i POINT id:ObjId {: ObjId.extendId(i); RESULT = ObjId; :} 
		;
		
expr ::= location:loc {: RESULT = loc; :}
		| method_call:mc {: RESULT = mc; :}
		| literal:lit {: RESULT = lit; :}
		| expr:e1 PLUS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.PLUS,e2); :}
		| expr:e1 MINUS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MINUS,e2); :}
		| expr:e1 PRODUCT expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.PRODUCT,e2); :}
		| expr:e1 DIVIDE expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.DIVIDE,e2); :}
		| expr:e1 MOD expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.MOD,e2); :}
		| expr:e1 LESS expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS,e2); :}
		| expr:e1 HIGH expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.HIGH,e2); :}
		| expr:e1 LESS_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.LESS_EQ,e2); :}
		| expr:e1 HIGH_EQ expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.HIGH_EQ,e2); :}
		| expr:e1 EQUAL expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.EQUAL,e2); :}
		| expr:e1 DISTINCT expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.DISTINCT,e2); :}
		| expr:e1 AND expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.AND,e2); :}
		| expr:e1 OR expr:e2 {: RESULT = new BinOpExpr(e1,BinOpType.OR,e2); :}
		| MINUS expr:e1 %prec UMINUS {: RESULT = new UnaryOpExpr(e1,UnaryOpType.MINUS); :}
		| NOT expr:e1 {: RESULT = new UnaryOpExpr(e1,UnaryOpType.NOT); :}
		| LPAR expr:e RPAR {: RESULT = e; :}
		;	      

assing_op ::= ASSIGN {: RESULT = AssignOpType.ASSIGN; :}
		| INC {: RESULT = AssignOpType.INC; :}
		| DEC {: RESULT = AssignOpType.DEC; :}
		;

literal ::= FLOAT_LITERAL:f {: RESULT = new FloatLiteral(f); :}
		| boolean_literal:b {: RESULT = b; :}
		| INTEGER_LITERAL:i {: RESULT = new IntegerLiteral(i); :}
		;

boolean_literal ::= TRUE:t {: RESULT = new BoolLiteral(t); :}
		| FALSE:f {: RESULT = new BoolLiteral(f); :}
		;
